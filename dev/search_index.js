var documenterSearchIndex = {"docs":
[{"location":"design/#Design-Motivations-and-Philosophy","page":"Design","title":"Design Motivations & Philosophy","text":"","category":"section"},{"location":"design/#A-Performance-Issue","page":"Design","title":"A Performance Issue","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"When dealing with multiple data types, often comes the problem to organise them into some kind of container. Think about the case in which we have an abstract type and its concrete subtypes:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"abstract type AbstractParent end\n\nstruct A <: AbstractParent\n    v::Vector\nend\n\nstruct B <: AbstractParent\n    v::Vector\nend\n\nstruct C\n    x::Number\nend","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"\nabstract type AbstractParent end\n\nstruct A <: AbstractParent\n    v::Vector\nend\n\nstruct B <: AbstractParent\n    v::Vector\nend\n\nstruct C\n    x::Number\nend\n\nv = [A(zeros(3)), B(zeros(3))]\nvA = [A(zeros(3)), A(zeros(3))]\nv2 = [A(zeros(3)), B(zeros(3)), C(1.0)]\n\n@inbounds function getval(vi)\n    return vi[1].v[1]\nend","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"and we want to organize the instances within an vector-like structure. The direct use of a Vector type would be inefficient in this case since its instace would result in a abstract vector type:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"v = [A(zeros(3)), B(zeros(3))]","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"or, in case the elements are not associated to the same parent to a vector of Any:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"v2 = [A(zeros(3)), B(zeros(3)), C(1.0)]","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Both cases are largely undesired from the performance point of view, because any operation would allocate something into memory. For example, in the first case, let's assume we want to write a function to get a value within the v vector contained in A or B:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@inbounds function getval(vi)\n    return vi[1].v[1]\nend","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Let's then benchmark this simple operation:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"julia> @benchmark getval($v)\nBenchmarkTools.Trial: 10000 samples with 1000 evaluations.\n Range (min … max):  31.621 ns … 867.008 ns  ┊ GC (min … max): 0.00% … 96.08%\n Time  (median):     33.290 ns               ┊ GC (median):    0.00%\n Time  (mean ± σ):   35.954 ns ±  15.665 ns  ┊ GC (mean ± σ):  0.68% ±  1.66%\n\n  ▂▅█▇▄▂    ▂▁▅▅▄▃▂▃▁▁                                         ▂\n  ████████▆█████████████▇▇▆▅▅▆▇▆▆▄▅▄▃▄▅▆▇▇▆▆▆▆▄▄▃▁▄▄▄▅▆▅▅▅▅▃▅▄ █\n  31.6 ns       Histogram: log(frequency) by time      64.2 ns <\n\n Memory estimate: 16 bytes, allocs estimate: 1.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"This is something very undesired since, at every call of getval, the vector v contained in either A or B is allocated before getting its first element. Indeed, constructing a concrete vector:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"vA = [A(zeros(3)), A(zeros(3))]","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"its performances results way better than the abstract one (approx 15 times faster for this simple example):","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"julia> @benchmark getval($vA)\nBenchmarkTools.Trial: 10000 samples with 1000 evaluations.\n Range (min … max):  2.396 ns … 56.949 ns  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     2.409 ns              ┊ GC (median):    0.00%\n Time  (mean ± σ):   2.554 ns ±  1.368 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n  █▄      ▆▄  ▂▁                                             ▁\n  ███▇▁▁▁▅██▇▇██▅▄▄▆▄▃▃▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▃▁▁▁▁▁▃▁▄ █\n  2.4 ns       Histogram: log(frequency) by time     3.39 ns <\n\n Memory estimate: 0 bytes, allocs estimate: 0.","category":"page"},{"location":"design/#Goal","page":"Design","title":"Goal","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"The goal of this package is then to create efficient containers for mixed-type data.","category":"page"},{"location":"design/#Design-Philosophy","page":"Design","title":"Design Philosophy","text":"","category":"section"},{"location":"design/#Efficiency","page":"Design","title":"Efficiency","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"While the use of Vector types is not efficient julia already possess a data type capable to efficiently handle multiple types: the Tuple. By exploiting a tuple, in fact, it is possible to have good performances while still keeping a certain degree of flexibility in terms of its arguments types.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Indeed, in our example, let's try to benchmark the getval function giving as input a tuple containing mixed-types:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"t = (A(zeros(3)), B(zeros(3)))","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Therefore, benchmarking it we can notice that it is possible to achieve the same performances of a concrete vector despite the different types involved:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"julia> @benchmark getval($t)\nBenchmarkTools.Trial: 10000 samples with 1000 evaluations.\n Range (min … max):  2.394 ns … 26.206 ns  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     2.408 ns              ┊ GC (median):    0.00%\n Time  (mean ± σ):   2.466 ns ±  0.917 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n   ▄███▆▂▃▂                              ▁▁                  ▂\n  █████████▃▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▃████▅▄▁▁▁▁▁▁▃▁▁▁▁▁▃▅ █\n  2.39 ns      Histogram: log(frequency) by time     2.61 ns <\n\n Memory estimate: 0 bytes, allocs estimate: 0.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Therefore for mixed-type data storage it is evident that a Tuple would be the best type to use.","category":"page"},{"location":"design/#Flexibility","page":"Design","title":"Flexibility","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"In order to increase the flexibility of the Tuple, NamedTuple are preferred, since can be indexed both via index (Int) and name (Symbol) with pratically equivalent performances w.r.t. the base Tuple type.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"As an example:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"function getval(vi, it)\n    return vi[it].v\nend\n\nv = [A(zeros(1)) for _ in 1:10000];\nt = (v..., B(zeros(3)));\nt2 = NamedTuple(\n    tuple([Symbol(\"v$i\") => v[i] for i in eachindex(v)]...)\n);","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Then benchmarking the Tuple indexing:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"julia> @benchmark getval($t, 801)\nBenchmarkTools.Trial: 10000 samples with 1000 evaluations.\n Range (min … max):  2.397 ns … 27.503 ns  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     2.406 ns              ┊ GC (median):    0.00%\n Time  (mean ± σ):   2.471 ns ±  0.940 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n  ▆██▇▃▂▁                              ▁▁▁                   ▂\n  ███████▅▃▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▃▁▁▇███▇▄▃▁▁▁▁▁▁▃▁▁▁▁▁▁▇▇ █\n  2.4 ns       Histogram: log(frequency) by time     2.61 ns <\n\n Memory estimate: 0 bytes, allocs estimate: 0.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Against the NamedTuple indexing:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"julia> @benchmark getval($t2, 801)\nBenchmarkTools.Trial: 10000 samples with 1000 evaluations.\n Range (min … max):  2.396 ns … 30.852 ns  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     2.404 ns              ┊ GC (median):    0.00%\n Time  (mean ± σ):   2.487 ns ±  1.119 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n  ▆██▇▄▃▃                             ▂▂▃▂                   ▂\n  ███████▄▁▁▁▁▅▃▁▁▃▁▃▃▁▁▁▁▁▃▁▁▃▁▁▁▁▁▁▃████▅▆▆▁▁▁▁▃▄▅▄▄▄▁▁▄██ █\n  2.4 ns       Histogram: log(frequency) by time     2.61 ns <\n\n Memory estimate: 0 bytes, allocs estimate: 0.\n\njulia> @benchmark getval($t2, :v801)\nBenchmarkTools.Trial: 10000 samples with 1000 evaluations.\n Range (min … max):  2.657 ns … 35.546 ns  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     2.671 ns              ┊ GC (median):    0.00%\n Time  (mean ± σ):   2.790 ns ±  1.266 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n  █▅     ▄▂                                                  ▁\n  ██▁▁▁▁▁██▄▄▇▄▃▃▁▁▁▃▁▁▃▃▁▁▁▁▁▃▃▃▁▁▁▄▄▁▃▃▁▄▃▁▁▄▄▄▅▅▄▅▅▅▄▄▃▄▄ █\n  2.66 ns      Histogram: log(frequency) by time     3.86 ns <\n\n Memory estimate: 0 bytes, allocs estimate: 0.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Show basically no difference for indexing via Int and a negligible difference when indexing by named fields (Symbol).","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Containers","category":"page"},{"location":"#Containers.jl","page":"Home","title":"Containers.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Containers.jl.","category":"page"},{"location":"#Container-creation","page":"Home","title":"Container creation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All you need to know to create a new mixed-type container using Containers.jl is how to use the @container macro. The user have the possibility to create both named and unnamed fields within the user-defined container. In the latter case, a default name will be assigned during the container creation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The basic syntax to be used to define a container is:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@container \"ContainerName\" begin\n    \"field-1\" → T1,\n    \"field-2\" → T2(1.0),\n    T1(1.0),\n    T2\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here ContainerName is the user-defined name of the container. In the begin ... end block the container's field are instead listed. Four possible formats are available:","category":"page"},{"location":"","page":"Home","title":"Home","text":"\"field-1\" → T1 – field defined as type T1 with name field-1;\n\"field-1\" → T2(1.0) – field defined as type T2 with name field-2;\nT1(1.0) – unnamed filed with type T1;\nT2 – unnamed filed with type T2;","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can also use a type-only definition of the field or a type constructor. In the latter case, there is the possibility to create an empty constructor for the new container, where all the fields initialization is handled by the container constructor itself.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Container-iteration","page":"Home","title":"Container iteration","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The possibility to store mixed-types within a single container is end in itself if not comes along with an efficient way to iterate it. Therefore, Containers.jl containes a set of utility tools which are designed to allocation-freely iterate the user-defined containers.  To best introduce their use, let's consider and example where a user defined container  Container is created and a function test_function is defined as:","category":"page"},{"location":"","page":"Home","title":"Home","text":"function test_function(c::Container)\n    val = 0.0\n    for i in eachindex(c)\n        c[i].x = 1.0i\n        val += iterate_function(c[i])\n    end\n    return val\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"This function modify a (common) field of the container and apply iterate_function to  compute a val variable, which is returned as output. The main issue here is associated  to the fact that, being each element of the container of a different type, this function allocates. ","category":"page"},{"location":"#Function-barriers-method","page":"Home","title":"Function barriers method","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"One possible solution is to exploit function barriers to avoid it at the cost of a very structured and less portable/maintainable code. As additional drawback, poor performances of this  approach are observed. For comparison, consider a 2 elements container and a iterate_function that simply reads a value within a container element:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> @benchmark test_barrier($c)\nBenchmarkTools.Trial: 10000 samples with 995 evaluations.\n Range (min … max):  27.461 ns …   2.720 μs  ┊ GC (min … max):  0.00% … 98.28%\n Time  (median):     29.851 ns               ┊ GC (median):     0.00%\n Time  (mean ± σ):   39.396 ns ± 144.435 ns  ┊ GC (mean ± σ):  21.35% ±  5.74%\n\n   ▆▆█▃                                                         \n  ▄████▇▅▅▆▄▃▃▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▁▂▁▂▂▂▂▂▁▁▂▂▂▂▂▂▂▂▂▂▂▁▂▂▂▂▂▂▂▂▂▁▂ ▃\n  27.5 ns         Histogram: frequency by time         66.8 ns <\n\n Memory estimate: 0 bytes, allocs estimate: 0.","category":"page"},{"location":"#Unwrapped-iteration-method","page":"Home","title":"Unwrapped iteration method","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Within Containers.jl and alternative approach is adopted by means of the introduction of two macros: @unwrap and @iterated. These have two precise roles:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@unwrap: decorate for loops. It transforms the expression in a specialized,   non-allocating one. For example, with reference to the test_function the for loop    can be transformed to:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@unwrap for i in eachindex(c)\n    c[i].x = 1.0i\n    val += iterate_function(c[i])\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"@iterated: decorate a function that containes Container's iterations. It is used   to tranform the part of the function associated to the Container. For example, with   reference to the test_function:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@iterated function test_iterated(c::ExampleContainer{N}) where {N}\n    val = 0.0\n    @unwrap for i in 1:N\n        c[i].x = 1.0i\n        val += iterate_function(c[i])\n    end\n    return val\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nNote that the use of @iterated comes always with the one of @unwrap as the latter transforms the for loop while the former the function itself. Note also that some modifications have been done to the new function:The function signature is now parametric in N. Here N represent the dimension of the    container and is a parameter automatically associated to the AbstractContainer    subtypes during their generation.\nThe for loop is still unwrapped with @unwrap but the iteration is specified using   the parametric argument N.These last two modification shall be applied to exploit @iterated functionalities at the current version of Containers.jl. This may change in future.","category":"page"},{"location":"","page":"Home","title":"Home","text":"With this approach, just with some simple adjustments to the code, a non-allocating, high-performance version of the function can be obtained resulting in (more than) a order of magnitude  speed-up:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> @benchmark test_iterated($c)\nBenchmarkTools.Trial: 10000 samples with 1000 evaluations.\n Range (min … max):  1.496 ns … 3.989 ns  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     1.508 ns             ┊ GC (median):    0.00%\n Time  (mean ± σ):   1.511 ns ± 0.042 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n      ▁▁▃▄▃ ▅▆▆██▇▇▅▂                                        \n  ▂▃▄▆█████▁█████████▁█▅▄▃▂▂▂▁▁▂▂▁▁▁▁▂▂▂▁▂▂▂▂▃▂▂▂▁▃▃▃▃▃▃▃▃▂ ▄\n  1.5 ns         Histogram: frequency by time       1.55 ns <\n\n Memory estimate: 0 bytes, allocs estimate: 0.","category":"page"}]
}
